---
title: The Missing Semester of Your CS Education(Data Wrangling)
date: 2022-04-03 20:46:00
tags: [The Missing Semester of Your CS]
description: 计算机教育中缺失的一课 The Missing Semester of Your CS Education
---

# Data Wrangling

这一节的主要内容是数据处理，将某种格式存储的数据转换成另外一种格式。

## 用来整理的数据以及相关的应用场景

日志处理通常是一个比较典型的使用场景，因为我们经常需要在日志中查找某些信息，这种情况下通读日志是不现实的。

研究一下系统日志，用ssh连接我自己的服务器(39.108.253.105)，看看哪些用户曾经尝试过登录我们的服务器：

```bash
ssh -l root 39.108.253.105 journalctl
```

![image-20220403211253725](https://ek1ng-typora.oss-cn-hangzhou.aliyuncs.com/img/image-20220403211253725.png)

能够得到特别多的信息，那这时候想得到有用的信息就需要过滤

```bash
ssh -l root 39.108.253.105 journalctl | grep sshd
```

sshd是ssh服务进程的名字，会发现还是很多，我们来改进一下：

```bash
ssh -l root 39.108.253.105 'journalctl | grep sshd | grep "Disconnected from"' | less
```

多出来的引号是什么作用呢？这么说吧，我们的日志是一个非常大的文件，把这么大的文件流直接传输到我们本地的电脑上再进行过滤是对流量的一种浪费。因此我们采取另外一种方式，我们先在远端机器上过滤文本内容，然后再将结果传输到本机。 `less` 为我们创建来一个文件分页器，使我们可以通过翻页的方式浏览较长的文本。

![image-20220403212301621](https://ek1ng-typora.oss-cn-hangzhou.aliyuncs.com/img/image-20220403212301621.png)

为了进一步节省流量，我们甚至可以将当前过滤出的日志保存到文件中，这样后续就不需要再次通过网络访问该文件了：

```bash
$ ssh -l root 39.108.253.105 'journalctl | grep sshd | grep "Disconnected from"' > ssh.log
$ less ssh.log
```

报错permission denied，不知道为啥...

我们先研究一下 `sed` 这个非常强大的工具。`sed` 是一个基于文本编辑器`ed`构建的”流编辑器” 。在 `sed` 中，您基本上是利用一些简短的命令来修改文件，而不是直接操作文件的内容（尽管您也可以选择这样做）。相关的命令行非常多，但是最常用的是 `s`，即*替换*命令，例如我们可以这样写：

```bash
ssh -l root 39.108.253.105 journalctl | grep sshd | grep "Disconnected from"| sed 's/.*Disconnected from //'
```

## 正则表达式

 `/.*Disconnected from /`，正则表达式通常以/开始和结束。

- `.` 除换行符之外的”任意单个字符”
- `*` 匹配前面字符零次或多次
- `+` 匹配前面字符一次或多次
- `[abc]` 匹配 `a`, `b` 和 `c` 中的任意一个
- `(RX1|RX2)` 匹配`RX1` 或 `RX2`
- `^` 行首
- `$` 行尾
- `{num1,num2}`匹配num1-num2个前面字符

回过头我们再看`/.*Disconnected from /`，我们会发现这个正则表达式可以匹配任何以若干任意字符开头，并接着包含”Disconnected from “的字符串。这也正式我们所希望的。`sed` 还可以非常方便的做一些事情，例如打印匹配后的内容，一次调用中进行多次替换搜索等。

想要匹配用户名后面的文本，尤其是当这里的用户名可以包含空格时，这个问题变得非常棘手！这里我们需要做的是匹配*一整行*：

```bash
 | sed -E 's/.*Disconnected from (invalid |authenticating )?user .* [^ ]+ port [0-9]+( \[preauth\])?$//'
```

开始的部分和以前是一样的，随后，我们匹配两种类型的“user”（在日志中基于两种前缀区分）。再然后我们匹配属于用户名的所有字符。接着，再匹配任意一个单词（`[^ ]+` 会匹配任意非空且不包含空格的序列）。紧接着后面匹配单“port”和它后面的一串数字，以及可能存在的后缀`[preauth]`，最后再匹配行尾。

问题还没有完全解决，日志的内容全部被替换成了空字符串，整个日志的内容因此都被删除了。我们实际上希望能够将用户名*保留*下来。对此，我们可以使用“捕获组（capture groups）”来完成。被圆括号内的正则表达式匹配到的文本，都会被存入一系列以编号区分的捕获组中。捕获组的内容可以在替换字符串时使用（有些正则表达式的引擎甚至支持替换表达式本身），例如`\1`、 `\2`、`\3`等等，因此可以使用如下命令：

```
 | sed -E 's/.*Disconnected from (invalid |authenticating )?user (.*) [^ ]+ port [0-9]+( \[preauth\])?$/\2/'
```

看完这些非常头疼，正则表达式好复杂

## 回到数据整理

`sed` 还可以做很多各种各样有趣的事情，例如文本注入：(使用 `i` 命令)，打印特定的行 (使用 `p`命令)，基于索引选择特定行等等。详情请见`man sed`

好难....确实没啥动力看下面的内容了，感觉光看有点难学明白，大概懂个意思过两天也忘了

## 课后练习

>1. 学习一下这篇简短的 [交互式正则表达式教程](https://regexone.com/).

感觉交互式教程还不错，在运用中对正则的规则有了一些印象

`\d`匹配数字，`\s`匹配空格，`\w`匹配字母，`^`表示行首，`$`表示行末，`()`表示一个组，

内容其实还挺不错的，不过有点摸了今天，就这样叭，后面的就不做了，确实感觉有点烦
