---
title: 动态规划
date: 2021-08-07 00:00:00
tags: [leetcode,algorithm]
---
#  动态规划

**声明：文章内容为作者阅读[labuladong的算法笔记](labuladong.gitee.io/)后的个人笔记分享**

## 动态规划解题框架

**动态规划有两种等价的实现方法**，自底向上的方法的时间复杂度函数通常具有更小的系数。

### 自顶向下的递归求解

尝试用递归模拟的方式暴力求解，递归是一种自顶向下的运算方式，例如斐波那契数列中，若需要求第10个斐波那契数，则需要求解第8、9个，若需要求解第9个则需要第7、8个，以此类推，从而根据最底层已知的第一个数、第二个数求出结果，在使用递归暴力求解中，我们只需要按照题目描述去用计算机语言来翻译内容，即可完成算法，但是这种暴力递归的解法大多数时候因为超时无法通过测试。对1中的暴力递归解法通过备忘录进行剪枝，什么是剪枝、如何剪枝需要在以下三个题目中体会，以文字方式概述即是，通过数组等数据结构存取子问题，从而避免子问题的重复计算，例如第10个斐波那契数，则需要求解第8、9个，若需要求解第9个则需要第7、8个，而若是只使用递归模拟，则第8个数的求解这一子问题就被重复计算了，子问题的重复计算将会极大增加运算量，从而极大增加时间复杂度。

### 自底向上的迭代求解

在斐波那契数的例子中，即是从第一个斐波那契数开始（底）运算至我们要求的第x个斐波那契数（顶），依次求解子问题，来解决最终的问题。

## Leetcode509.斐波那契数列

### 暴力递归

```java
class Solution {
    public int fib(int n) {
        if (n == 0) return 0;
        if (n == 1 || n == 2) return 1;
        return fib(n - 1) + fib(n - 2);
    }
}
```

### 自顶向下的递归求解（添加备忘录）

```java
class Solution {
    public int fib(int n) {
        int[] memo = new int[n + 1];
        if (n == 0 || n == 1) return n;
        memo[0] = 0;
        memo[1] = 1;
        for (int i = 2;i <= n;i++){
            memo[i] = memo[i-1] + memo[i-2];
        }
        return memo[n];
    }
}
```

### 自底向上的迭代求解

### 最优解（同时由于题目只需要3个变量来存3个连续的斐波那契数，因此使用三个变量而不是数组来减少空间使用）

```java
class Solution {
    public int fib(int n) {
        if (n == 0 || n == 1) return n;
        int a = 0,b = 1,c = 1;
        for (int i = 2;i <= n;i++){
            c = a + b;
            a = b;
            b = c;
        }
        return c;
    }
}
```



## Leetcode322.零钱兑换

### 暴力递归

```java
class Solution {
    public int coinChange(int[] coins, int amount) {
        //base case
        if(amount == 0) return 0;
        if(amount < 0) return -1;
        
        int res = Integer.MAX_VALUE;
        for (int coin : coins) {
            int subProblem = coinChange(coins,amount - coin);
            if (subProblem == -1) continue;
            res = Math.min(res,subProblem + 1);
        }

        return res == Integer.MAX_VALUE ? -1 : res;
    }
}
```



### 自顶向下的递归求解（添加备忘录）

```java
class Solution {
    int[] memo; 
    public int coinChange(int[] coins, int amount) {
        memo = new int[amount + 1];
        Arrays.fill(memo, -666);

        return dp(coins,amount); 
    }

    private int dp(int[] coins,int amount) {
        if(amount == 0) return 0;
        if(amount < 0) return -1;
        if(memo[amount] != -666)
            return memo[amount];

        int res = Integer.MAX_VALUE;
        for (int coin : coins) {
            int subProblem = dp(coins,amount - coin);
            if (subProblem == -1) continue;
            res = Math.min(res,subProblem + 1);
        }
        memo[amount] = (res == Integer.MAX_VALUE) ? -1 : res;
        return memo[amount];
    }
}
```



### 自底向上的迭代求解

```java
class Solution {
    public int coinChange(int[] coins, int amount) {
        int[] dp = new int[amount + 1];
        Arrays.fill(dp,amount + 1);

        //base case
        dp[0] = 0;
        //外层for遍历所有状态所有取值
        for (int i = 0; i< dp.length; i++) {
            //内层for循环求所有取值中的最小值
            for (int coin : coins) {
                //子问题无解
                if (i - coin < 0) continue;
                //状态转移
                dp[i] = Math.min(dp[i], 1 + dp[i - coin]);
            }
        }
        return (dp[amount] == amount + 1) ? -1 : dp[amount]; 
    }
}
```

## Leetcode72.编辑距离

### 暴力递归

```python
class Solution:
    def minDistance(self, s1: str, s2: str) -> int:
        # dp(i,j)表示 s1[0..i] 和 s2[0..j]的最小编辑距离
        def dp(i,j):
            if i == -1: return j + 1
            if j == -1: return i + 1

            if s1[i] == s2[j]:
                return dp(i - 1, j - 1)
            else:
                return min(
                    dp(i, j - 1) + 1,   # 插入
                    dp(i - 1, j) + 1,   # 删除
                    dp(i - 1, j - 1) + 1 # 替换
                )
        return dp(len(s1) - 1, len(s2) - 1)
```



### 自顶向下的递归求解（添加备忘录）

```python
class Solution:
    def minDistance(self, s1: str, s2: str) -> int:
        #备忘录
        memo = dict()

        # dp(i,j)表示 s1[0..i] 和 s2[0..j]的最小编辑距离
        def dp(i,j):
            if i == -1: return j + 1
            if j == -1: return i + 1
            # 查备忘录
            if (i,j) in memo:
                return memo[(i,j)]
            if s1[i] == s2[j]:
                memo[(i,j)] = dp(i - 1, j - 1)
            else:
                memo[(i,j)] = min(
                    dp(i, j - 1) + 1,   # 插入
                    dp(i - 1, j) + 1,   # 删除
                    dp(i - 1, j - 1) + 1 # 替换
                )
            return memo[(i,j)]
            
        return dp(len(s1) - 1, len(s2) - 1)
```



### 自底向上的迭代求解

```java
class Solution {
    //自底向上迭代求解
    public int minDistance(String s1, String s2) {
        int m = s1.length(), n = s2.length();
        // dp[i][j]数组的含义
        int[][] dp = new int[m + 1][n + 1];

        // base case
        for (int i = 1; i <= m; i++)
            dp[i][0] = i;
        for (int j = 1; j <=n; j++)
            dp[0][j] = j;
        
        // 自底向上求解
        for (int i = 1; i <= m; i++) {
            for(int j = 1; j <= n; j++) {
                if (s1.charAt(i-1) == s2.charAt(j-1)) {
                    dp[i][j] = dp[i - 1][j - 1];
                } else {
                    dp[i][j] = min(
                        dp[i - 1][j] + 1,
                        dp[i][j - 1] + 1,
                        dp[i - 1][j - 1] + 1
                    );
                }
            }
        }
        return dp[m][n];
    }
    int min(int a, int b, int c){
        return Math.min(a,Math.min(b,c));
    }   
}
```

