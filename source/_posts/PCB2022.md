---
title: 鹏城杯 2022 web writeup
date: 2022-07-03 10:28:00
updated: 2022-07-03 11:39:00
tags: [ctf,security]
description: 近期打的一场线上CTF比赛，赛后复现
---
## 简单包含

这个题目环境还是比较简单，访问题目环境可以直接看到源代码

```php
<?php 
highlight_file(__FILE__);
include($_POST['flag']);
//flag in /var/www/html/flag.php
```

![图 1](https://s2.loli.net/2022/07/03/mh4M2dHBYSzkf8e.png)  

然后我一开始是尝试了比较常规的思路，就是用php的伪协议然后base64绕过处理的，不过发现会被WAF，然后也是没找到绕WAF的方法。

协会学长的做法是用nginx日志包含，因为php中include这个函数会去检测读到的文件里面的`<？php ？>`标签并且执行标签内的php代码，而我们通过`/var/xxx/../log`这个技巧可以绕过`/var/log`的WAF,来成功包含nginx的日志文件，那nginx的日志文件里面会对HTTP请求做记录，自然也包含User-Agent请求头，这样的话将恶意代码写在UA请求头中并且包含，就可以成功RCE了。不过我在复现的时候不知道为什么看不到cat出来的flag,因此用bash提供的base64库试了试发现可以看到转码后的flag。

![图 1](https://s2.loli.net/2022/07/02/Rucx5vWHe47m8ZX.png)  

![图 2](https://s2.loli.net/2022/07/03/5uzSyAYaNE4B69K.png)  

## Easygo

```go
package main

import (
        "database/sql"
        "fmt"
        "log"
        "net/http"

        "github.com/gin-gonic/gin"
        _ "github.com/lib/pq"
)

type CtfService struct {
        Db *sql.DB
}

type Juice struct {
        ID   int
        Name string
}

func (cs *CtfService) Get(c *gin.Context) {
        id := c.Param("id")
        var juices []Juice
        query := fmt.Sprintf("SELECT * FROM juice WHERE id = '%s'", id)
        rows, err := cs.Db.Query(query)
        if err != nil {
                if err == sql.ErrNoRows {
                        c.JSON(http.StatusNotFound, gin.H{"error": err.Error()})
                } else {
                        c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
                }

        } else {
                defer rows.Close()
                for rows.Next() {
                        var juice Juice
                        err := rows.Scan(&juice.ID, &juice.Name)
                        if err == nil {
                                juices = append(juices, juice)
                        }
                }
                c.JSON(http.StatusOK, gin.H{"result": juices})
        }
}

func initDb() *sql.DB {
        connStr := "host=postgresql user=postgres dbname=juice_market sslmode=disable"
        db, err := sql.Open("postgres", connStr)
        if err != nil {
                log.Fatal(err)
        }
        return db
}

func setupRouter() *gin.Engine {
        r := gin.Default()
        db := initDb()
        service := CtfService{Db: db}

        r.GET("/ping", func(c *gin.Context) {
                c.String(http.StatusOK, "pong")
        })

        r.GET("/juice/:id", service.Get)

        return r
}

func main() {
        r := setupRouter()
        r.Run(":8080")
}
```

其实这个题目可以在github找到对应的仓库<https://github.com/KaanSK/golang-sqli-challenge>，然后作者也是给出了做法。

## can_u_login

## 高手高手高高手
