---
title: linux 0.11的源码阅读笔记
date: 2022-06-01 22:49:00
updated: 2022-06-02 21:12:00
tags: [os]
description: linux 0.11的源码阅读笔记
---

# linux 0.11的源码阅读笔记

最近看到这个github仓库[flash-linux0.11-talk](https://github.com/sunym1993/flash-linux0.11-talk),觉得还算是蛮有意思的，加上网络编程的课程又有抄写一段tcp协议实现代码或者交一篇linux内核源码阅读的笔记，还是比较讨厌这种低效率的抄写的所以就想写篇文章记录一下粗浅阅读源码后的大概了解，这个github仓库作者的文章我觉得写的还是不错的对于我这类小白而言，也比较有看得下去的动力。

## 运行os前的准备工作是如何完成的

### 开机

嗯如果问电脑是如何一步一步开始运行操作系统的，那么第一件事情当然是按下开机键啦。

### 加载启动区

在按下开机键后会，主板上写死的Bios程序会加载硬盘的启动区，也就是BIOS会将把硬盘上启动区代码这段512个Byte大小的数据，复制到内存中0x7c00这个位置并且跳转到这个位置开始执行这段程序。

那么对于linux0.11来看，这个512Byte大小的启动程序就是/boot目录下的bootsect.s这个文件。按下开机键后，它会被编译成二进制文件，并且被存放在硬盘中的0盘0道1扇区。值得一提的是，当硬盘中的0盘0道1扇区的512字节大小的数据最后两个字节为0x55和0xaa时，Bios就会认为这段512Byte的程序是启动区并且在启动的时候区加载这段程序。因此bootsect.s经过编译后的二进制程序就会被Bios认为是启动区，那么Bios就会和我们上面说的一样，将这段数据复制到内存中的0x7c00并且跳转到这个位置，开始执行这段程序。

我们来看一下bootsect.s中写了什么
这是前面的一部分

```asm
start:
 mov ax,#BOOTSEG
 mov ds,ax
 mov ax,#INITSEG
 mov es,ax
 mov cx,#256
 sub si,si
 sub di,di
 rep
 movw
 jmpi go,INITSEG
go: mov ax,cs
 mov ds,ax
 mov es,ax
; put stack at 0x9ff00.
 mov ss,ax
 mov sp,#0xFF00  ; arbitrary value >>512

; load the setup-sectors directly after the bootblock.
; Note that 'es' is already set up.
```

这张16位CPU寄存器的图可以简单记忆一下，后面很多地方都需要用到。
![图 1](https://s2.loli.net/2022/06/02/x75ioKZgly3VFzE.png)  

这段汇编前两句的意义是将0x07c0这个值复制到ax寄存器，再将ax寄存器的值复制到ds寄存器。ds是个16位的段寄存器，具体表示数据段寄存器，在内存寻址时充当段基址的作用。简单的说就相当于一个偏移量，再之后的汇编中，比如`mov ax,[0x0001]`，实际上是对ds+0x0001的地址的值复制给了ax寄存器，这是一种基址寻址的方式，显然这里设置ds的值是为了我们之后通过基址，访问对应内存中的数据。

我们把为什么给ds赋值说清楚了，那ds的值为什么是0x07c0呢？之前我们不是说Bios将数据复制到内存中的0x7c00吗，这里为为什么刚好差了16倍呢？

我们需要先来解释实模式是什么，在实模式下，内存寻址方式和8086相同，由16位段寄存器的内容乘以16（10H）当做段基地址，加上16位偏移地址形成20位的物理地址。最大寻址空间1MB，最大分段64KB。可以使用32位指令。32位的x86 CPU用做高速的8086。在实模式下，所有的段都是可以读、写和可执行的。x86为了让自己在16位实模式下能访问到20位地址线，段基址会先左移4个2进制位，也就是一个16进制位，因此**0x07c0左移4位后为0x7c00**，也就是Bios将bootsect.s编译后的程序所存放到的位置，将ds设置为咱们启动程序所在的这个位置显然是很有必要的，因为我们要执行的操作系统的boot区的代码会被bios放在这段对应内存上，这段程序中的数据也需要相对于0x7c00这个地址去寻址使用，这样可以方便我们通过基址访问内存中的数据。

同样的方式，es寄存器的值变成了0x9000,cx寄存器的值变成了256(10进制)。

而`sub a,b`表示`a=a-b`,因此si，di寄存器的值变为0了这里。

到这里我们对不少寄存器的值进行了操作，但是也并没有看到什么实际的意义，因为这些赋值语句主要是为了下一句`rep movw`指令服务的，`rep movw`表示重复执行`movw`，而`movw`表示复制一个字(16 bit)，并且复制`cx`次，也就是256次，从`ds:si`复制到`es:di`，一次复制16bit大小的数据。

因此这句`rep movw`的作用就是把从内存地址0x7c00开始往后512Byte大小的数据，复制到0x90000处，那么现在启动区代码已经被挪到了0x90000。

接下来是一个跳转指令

```asm
jmpi go,0x9000
go: mov ax,cs
    mov ds,ax
    mov es,ax
    mov ss,ax
    mov sp,#0xFF00
```

jmpi是一个段间跳转指令，表示跳转到0x9000:go处执行，段基址：偏移地址的计算为基址左移4个2进制位+偏移地址，也就是跳转到0x90000+go这个内存地址上执行。那么0x90000我们很熟悉，我们将boot的代码从0x7c00移动到了0x90000,go又是什么意思呢？go是一个标签，最后编译成机器码的时候会被翻译成一个值，值的大小就是go这个标签在文件内的偏移地址。实际上啊，就是跳转到go后面`mov ax,cs`这句汇编所在的内存地址并且开始执行。假如`mov ax,cx`这行代码位于这个编译后二进制文件的0x08处，那么go就等于0x08,CPU就会跳转到0x90008开始执行。

简单总结一下，到这里为止的汇编代码的内容就是将一段512Byte大小的代码从硬盘上的启动区，移动到了内存的0x7c00,然后又被移动到0x90000,并且跳转到偏移go这个标签对应的地址处，开始执行下面这一串mov指令。

下面这些mov指令很容易看懂，把cs给ax,把ax给ds，es,ss,给sp赋值0xff00。

我们来理一理现在各个寄存器的值和它们对应的作用。
![图 1](https://s2.loli.net/2022/06/02/x75ioKZgly3VFzE.png)  
cs寄存器是代码段寄存器，CPU当前正在执行的代码在内存中的位置，就是cs:ip这组寄存器配合指向的。因为之前执行了`jmpi go,0x90000`这条段间跳转指令，所以cs寄存器的值就是0x90000,ip寄存器里的值是go这个标签的偏移地址，那么上面的三条mov指令把cs的值赋值给了ax,ds,es,ss,这些寄存器的值现在都是0x90000。

ds是数据段寄存器，一开始我们给他赋值了0x07c0,并且说主要的作用是方便通过基址访问对应数据，现在代码被移动到0x90000这段地址上面了，自然ds也应该赋值为0x90000。

es是扩展段寄存器，可以先不管。

ss为栈段寄存器，后面要配合栈基址寄存器sp表示此时的栈顶地址，ss和sp主要用于访问栈。此时sp寄存器被赋值为0xff00,所以目前栈顶地址是ss:sp所指向的之地0x90000+0x0FF00，栈顶地址0x9FF00,具体表现为栈段寄存器ss为0x9000，栈基址寄存器sp为0xFF00,栈是向下发展的，这个栈顶指针0x9FF00，远大于0x90000,栈向下发展很难撞见代码所在的为止，也就比较安全。

至此为止，加载启动区，也就是将这512Byte加载到内存中的工作咱们已经完成了。现在我们可以总结一下总共做了哪些事情，首先start这块，boot代码从硬盘移动到内存中0x7c00,又移动到了0x9FF00，数据段急促请你ds和代码段寄存器cs都被设置为了0x9000,为了方便跳转和内存访问。栈段寄存器ss和栈基址寄存器sp也设置了合理的取值。总的来说，就是对如何访问代码，如何访问数据，如何访问栈进行了一下内存的初步规划。访问代码和访问数据的的规划方式就是分别给cs、ip和ds设置基址，访问栈的规划方式就是把栈顶指针只想了一个远离代码位置的地方。

### 加载setup.s

### 加载内核

### 设置GDT

### 进入保护模式

### 分页机制

### 跳转到内核
