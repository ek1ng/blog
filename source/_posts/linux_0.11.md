---
title: linux 0.11的源码阅读笔记
date: 2022-06-01 22:49:00
updated: 2022-06-01 22:49:00
tags: [os]
description: linux 0.11的源码阅读笔记
---

# linux 0.11的源码阅读笔记

最近看到这个github仓库[flash-linux0.11-talk](https://github.com/sunym1993/flash-linux0.11-talk),觉得还算是蛮有意思的，加上网络编程的课程又有抄写一段tcp协议实现代码或者交一篇linux内核源码阅读的笔记，还是比较讨厌这种低效率的抄写的所以就想写篇文章记录一下粗浅阅读源码后的大概了解，这个github仓库作者的文章我觉得写的还是不错的对于我这类小白而言，也比较有看得下去的动力。

## 运行os前的准备工作是如何完成的

### 开机

嗯如果问电脑是如何一步一步开始运行操作系统的，那么第一件事情当然是按下开机键啦。

### 加载启动区

在按下开机键后会，主板上写死的Bios程序会加载硬盘的启动区，也就是BIOS会将把硬盘上启动区代码这段512个Byte大小的数据，复制到内存中0x7c00这个位置并且跳转到这个位置开始执行这段程序。

那么对于linux0.11来看，这个512Byte大小的启动程序就是/boot目录下的bootsect.s这个文件。按下开机键后，它会被编译成二进制文件，并且被存放在硬盘中的0盘0道1扇区。值得一提的是，当硬盘中的0盘0道1扇区的512字节大小的数据最后两个字节为0x55和0xaa时，Bios就会认为这段512Byte的程序是启动区并且在启动的时候区加载这段程序。因此bootsect.s经过编译后的二进制程序就会被Bios认为是启动区，那么Bios就会和我们上面说的一样，将这段数据复制到内存中的0x7c00并且跳转到这个位置，开始执行这段程序。

我们来看一下bootsect.s中写了什么
前两行代码

```asm
start:
 mov ax,#BOOTSEG
 mov ds,ax
 mov ax,#INITSEG
 mov es,ax
 mov cx,#256
 sub si,si
 sub di,di
 rep
 movw
 jmpi go,INITSEG
go: mov ax,cs
 mov ds,ax
 mov es,ax
; put stack at 0x9ff00.
 mov ss,ax
 mov sp,#0xFF00  ; arbitrary value >>512

; load the setup-sectors directly after the bootblock.
; Note that 'es' is already set up.
```

![图 1](https://s2.loli.net/2022/06/01/tfvRB5HljMDFZKr.png)  

这段汇编前两句的意义是将0x07c0这个值复制到ax寄存器，再将ax寄存器的值复制到ds寄存器。ds是个16位的段寄存器，具体表示数据段寄存器，在内存寻址时充当段基址的作用。简单的说就相当于一个偏移量，再之后的汇编中，比如`mov ax,[0x0001]`，实际上是对ds+0x0001的地址的值复制给了ax寄存器，这是一种基址寻址的方式，显然这里设置ds的值是为了我们之后通过基址，访问对应内存中的数据。

我们把为什么给ds赋值说清楚了，那ds的值为什么是0x07c0呢？之前我们不是说Bios将数据复制到内存中的0x7c00吗，这里为为什么刚好差了16倍呢？

x86为了让自己在16位这个实模式下能访问到20位地址线，段基址会先左移4个2进制位，也就是一个16进制位，**0x07c0左移4位后为0x7c00**，也就是Bios将bootsect.s编译后的程序所存放到的位置，将ds设置为咱们启动程序所在的这个位置显然是很有必要的，因为我们要执行的操作系统的boot区的代码会被bios放在这段对应内存上，这段程序中的数据也需要相对于0x7c00这个地址去寻址使用，这样可以方便我们通过基址访问内存中的数据。

同样的方式，es寄存器的值变成了0x9000,cx寄存器的值变成了256(10进制)。

而`sub a,b`表示`a=a-b`,因此si，di寄存器的值变为0了这里。

到这里我们对不少寄存器的值进行了操作，但是也并没有看到什么实际的意义，因为这些赋值语句主要是为了下一句`rep movw`指令服务的，`rep movw`表示重复执行`movw`，而`movw`表示复制一个字(16 bit)，并且复制`cx`次，也就是256次，从`ds:si`复制到`es:di`，一次复制16bit大小的数据。

因此我们再看这一段汇编的作用，就是把从内存地址0x7c00开始往后512Byte大小的数据，复制到0x90000处，那么现在这段代码已经被挪到了0x90000这个位置了。

接下来是一个跳转指令

```
jmpi go,0x9000
go: mov ax,cs
    mov ds,ax
    mov es,ax
    mov ss,ax
    mov sp,#0xFF00
```

jmpi是一个段间跳转指令，表示跳转到0x9000:go处执行，段基址：偏移地址的计算为基址左移4个2进制位+偏移地址，也就是跳转到0x90000+go这个内存地址上执行。那么0x90000我们很熟悉，我们将boot的代码从0x7c00移动到了0x90000,go又是什么意思呢？go是一个标签，最后编译成机器码的时候会被翻译成一个值，值的大小就是go这个标签在文件内的偏移地址。实际上啊，就是跳转到go后面`mov ax,cs`这句汇编所在的内存地址并且开始执行。假如`mov ax,cx`这行代码位于这个编译后二进制文件的0x08处，那么go就等于0x08,CPU就会跳转到0x90008开始执行。

至此，汇编代码的内容就是将一段512Byte大小的代码从硬盘上的启动区，移动到了内存的0x7c00,然后又被移动到0x90000,并且跳转到偏移go这个标签对应的地址处，开始执行下面这一串mov指令。

这段汇编的意思很简单，把cs给ax,把ax给ds，es,ss,给sp赋值0xff00。

cs寄存器是代码段寄存器，CPU当前正在执行的代码在内存中的位置，就是cs:ip这组寄存器配合指向的。因为

### 加载setup.s

### 加载内核

### 设置GDT

### 进入保护模式

### 分页机制

### 跳转到内核
